[
["index.html", "ggplot2忍者秘笈 前言", " ggplot2忍者秘笈 余光创 前言 这本书源自于我在公众号biobabble上分享了许多的ggplot2技巧，我觉得有必要整理一下。 扫码关注，学更多技巧 如果你发现本书有错误或者其它问题，欢迎在github上提交issue或pull request。如果是pull request的话，请在commit的消息中写一句：“我把版权转交给余光创，”，这样我才能拥有出版这本书或者以其它形式发布的版权。 "],
["chapter-why-ggplot2.html", "Chapter 1 为什么要使用ggplot2", " Chapter 1 为什么要使用ggplot2 "],
["chapter-grammar-graphics.html", "Chapter 2 图形语法简介", " Chapter 2 图形语法简介 "],
["chapter-distribution.html", "Chapter 3 可视化数据分布", " Chapter 3 可视化数据分布 "],
["chapter-multi-distribution.html", "Chapter 4 可视化多个数据分布", " Chapter 4 可视化多个数据分布 "],
["chapter-ratio.html", "Chapter 5 可视化比值", " Chapter 5 可视化比值 abcd "],
["chapter-facet.html", "Chapter 6 不一样的分面 6.1 背景数据 6.2 特定的分面 6.3 额外的分面 6.4 坐标轴截断 6.5 不想干的分面", " Chapter 6 不一样的分面 分面（facet）是将数据分解成多个子集，对各个子集分别进行作图，并联合进行展示。比如我们所熟知的数据iris和mtcars中，iris中有三个物种，而mtcars中的车有4、6和8个轮子的。我们可以按照这些分类变量，对数据进行切割作图。比如： library(ggplot2) ggplot(mtcars, aes(mpg, disp)) + geom_point() + facet_grid(. ~ cyl) ggplot2提供了facet_grid()和facet_wrap()两个函数，来实现分面可视化。上面的示例向我们展示了分面的用法，它提供给我们以纵向或横向的形式比较不同的类别，这里比较一个变量cyl（轮子数）中的三个元素，这是分面最常用的用法，同一变量中不同的取值，对数据进行切割，以横向或纵向比较，比如不同物种中某个相同的特征进行比较，按照月份切割可视化一年的数据，机器学习中训练集和测试集的比较。 6.1 背景数据 ggplot(mtcars, aes(mpg, disp)) + geom_point(data = mtcars[, -2], color = &#39;grey&#39;) + geom_point(aes(color = factor(cyl))) + facet_grid(. ~ cyl) 6.2 特定的分面 d &lt;- data.frame(mpg=20, disp=280, cyl=6, label=&quot;额外的数据&quot;) ggplot(mtcars, aes(mpg, disp)) + geom_point(data = mtcars[, -2], color = &#39;grey&#39;) + geom_point(aes(color = factor(cyl))) + facet_grid(. ~ cyl) + geom_point(data = d, shape = 2, size=10, color = &#39;red&#39;) + geom_text(aes(label=label), data = d, size=5) 6.3 额外的分面 d &lt;- data.frame(mpg=sample(mtcars$mpg, 20), disp=sample(mtcars$disp, 20), cyl=2) ggplot(mtcars, aes(mpg, disp)) + geom_point(data = mtcars[, -2], color = &#39;grey&#39;) + geom_point(aes(color = factor(cyl))) + facet_grid(. ~ cyl) + geom_point(data = d) 这样就加上额外的分面了，当然有一个问题是额外加的分面没有上色，这个解决方案就是先不加色，而在后面再映射颜色。 ggplot(mtcars, aes(mpg, disp)) + geom_point(data = mtcars[, -2], color = &#39;grey&#39;) + geom_point() + facet_grid(. ~ cyl) + geom_point(data = d) + aes(color = factor(cyl)) 6.4 坐标轴截断 set.seed(2019-01-19) d &lt;- data.frame( x = 1:20, y = c(rnorm(5) + 4, rnorm(5) + 20, rnorm(5) + 5, rnorm(5) + 22) ) ggplot(d, aes(x, y)) + geom_col() library(dplyr) breaks = c(7, 17) d$.type &lt;- NA d$.type[d$y &lt; breaks[1]] = &quot;small&quot; d$.type[d$y &gt; breaks[2]] = &quot;big&quot; d &lt;- filter(d, .type == &#39;big&#39;) %&gt;% mutate(.type = &quot;small&quot;, y = breaks[1]) %&gt;% bind_rows(d) mymin = function(y) ifelse(y &lt;= breaks[1], 0, breaks[2]) p &lt;- ggplot(d, aes(x, y)) + geom_rect(aes(xmin = x - .4, xmax = x + .4, ymin = mymin(y), ymax = y)) + facet_grid(.type ~ ., scales = &quot;free&quot;) + theme(strip.text=element_blank()) p 6.5 不想干的分面 在额外的分面一节中，应该看出一点端倪。 如ggtree中的facet_plot "],
["chapter-summary.html", "Chapter 7 统计量", " Chapter 7 统计量 library(ggplot2) pups &lt;- nlme::RatPupWeight %&gt;% janitor::clean_names() %&gt;% dplyr::mutate(litter = as.integer(litter)) p &lt;- ggplot(pups, aes(x = litter, y = weight, color = treatment)) 针对某一个x值，我们可以画出相应y的统计量，比如均值、方差等，这些都可以“手工”的方式通过图层叠加来实现。 p + geom_jitter(shape=1) + stat_summary(fun.y = &quot;mean&quot;, size=2, geom=&quot;point&quot;, color = &#39;black&#39;) + stat_summary(fun.data = mean_cl_normal, geom=&quot;errorbar&quot;, width=.1, color=&#39;black&#39;) 而图层不单单是画出几何图形而已，有一些是需要计算统计量的，最常见也最容易理解的箱式图图层geom_boxplot，需要计算四分位数，而有一些图层虽然看上去不需要做计算，比如显示误差的geom_errorbar，通常需要我们提供ymin和ymax，然而它按照我们提供的值去显示，没有涉及到图层内部的计算，但这只是默认行为而已，如果有留意ggplot2图层的默认参数的话，大概是会发现很多图层都有一个stat = \"identity\"的参数，这表示按照输入数据的值来画，不涉及计算，比如画柱状图的geom_col就是这样，它会按照用户输入的计算来画柱子的高度，而geom_bar的参数却不stat = \"count\"它则会去数数。所以这些图层都有stat参数，意味着我们可以改变默认行为的统计量来画图，比如说箱式图吧，箱体是25%, 50%, 70%的分位数来画的，假设我想用mean-sd, mean, mean+sd来画呢？当然可以。 f &lt;- function(y) { r &lt;- quantile(y, probs = c(0.05, 0.25, 0.5, 0.75, 0.95)) r[2] &lt;- mean(y) - sd(y) r[3] &lt;- mean(y) r[4] &lt;- mean(y) + sd(y) names(r) &lt;- c(&quot;ymin&quot;, &quot;lower&quot;, &quot;middle&quot;, &quot;upper&quot;, &quot;ymax&quot;) r } p1 &lt;- p + stat_summary(fun.data=f, geom=&#39;boxplot&#39;, width=.8) p2 &lt;- p + geom_boxplot(aes(group = litter)) cowplot::plot_grid(p1, p2, labels = c(&quot;mean +- sd&quot;, &quot;quantile&quot;)) 这一招也是我在Proteomic investigation of the interactome of FMNL1 in hematopoietic cells unveils a role in calcium-dependent membrane plasticity图一中把箱式图的中位数换成均值所使用的方法。 使用stat_smooth(method = \"lm\", formula = y ~ 1)，可以展示某一x取值区间的平均y值。 p + geom_point() + stat_smooth(method = &quot;lm&quot;, formula = y ~ 1) 如果要计算中位数的话，可以使用rlm： library(MASS) p + geom_point() + stat_smooth(method = &quot;rlm&quot;, formula = y ~ 1) "],
["references.html", "References", " References "]
]
