[
["index.html", "ggplot2忍者秘笈 前言", " ggplot2忍者秘笈 余光创 前言 这本书源自于我在公众号biobabble上分享了许多的ggplot2技巧，我觉得有必要整理一下。 扫码关注，学更多技巧 如果你发现本书有错误或者其它问题，欢迎在github上提交issue或pull request。如果是pull request的话，请在commit的消息中写一句：“我把版权转交给余光创，”，这样我才能拥有出版这本书或者以其它形式发布的版权。 "],
["chapter-why-ggplot2.html", "Chapter 1 为什么要使用ggplot2 1.1 R画图系统 1.2 base plot vs ggplot2", " Chapter 1 为什么要使用ggplot2 1.1 R画图系统 R有不同的画图系统，比如支持3D的rgl包是基于OpenGL的，而支持交互的iplots包是基于JavaGD的，更不要提现在对Javascript封装的各种可视化的包，一般我们讲R的画图系统，都特定R本身的画图系统，不包括上面提到的各种封装的包。R的画图系统有两个，base graphics system和grid graphics system，它们对于画图提供底层的支持。R语言可视化的包非常多，能够称之为图形系统的，我认为就只有base和grid，虽然在网上经常看到ggplot2 graphics system这样的说法，但ggplot2是不提供画图底层支持的，它本身是基于grid开发的，我觉得是有必要区分开来，图形系统是base和grid，而lattice和ggplot2这种通用目的的可视化包，称之为可视化系统（visualization system），另外各种各样针对特定做图目的的衍生包称之为图形应用（graphic applications）。 base画图系统是基于S3面向对象来设计的，R的基础数据结构基本上都有plot()方法，直接plot(object)便可对object进行做图，非常方便，要对图像进行注释，比如加拟合的曲线，加文本等，相对于ggplot2等其它软件来说，是以一种非常符合直觉的方式来进行的，这是base系统的好处，另一方面base的代码即使是10年前的，现在也能重复出图，但ggplot2就不行了，版本的迭代，有可能使你现在的代码变得不可用，但这种情况发生在base系统的可能性就极低。base画图相当于在一块静态的画布上不断添加素，可以说只给你纸笔但没有橡皮擦，另一方面如果你要设计复杂的图形布局，包括缩放、嵌套图形等，用base就非常困难！ 而grid的设计就是为了解决这一问题，一方面graphic object可修改，相当于给了你橡皮擦，另一方面viewports系统，复杂的图形布局轻而易举就可实现，不过你要时刻清楚自己操作的是堆栈中的那一个viewport。grid的学习难度比较大，但它是目前R语言中最灵活、最强大的画图系统。 lattice包S-plus中trellis图形系统的R语言实现，基于grid，可以非常方便地应对多重变量的数据可视化，另外vcd包也是基于grid系统，它针对的是分类变量的数据可视化，实现了诸如mosaic plot, spine plot, sieve diagram等。这些包虽然没有ggplot2受欢迎，但它们的设计简单，方便我们使用grid包对可视化结果修改细节。而ggplot2如果主题系统不支持的话，用grid来修改就变得很复杂。 ggplot2的优势在于实现了图形语法，让我们以更高的抽象水平来表达图形，画图无非是一个映射过程，而复杂的图通过不同几何对象的图层叠加得以实现，它本身是一门语言，我们通过学习简单的语法就可以拥有强大的表达能力，这是推荐大家学习的理由之一！另外现在ggplot2的用户非常多，扩展包也非常多，对于很多特殊领域的应用，有很多扩展包实现，比如说在进化树可视化上我们有ggtree包，这也是推荐大家学习的理由，社区的力量非常重要，你面临的问题可能已经有人解决，或者你遇到的困难，有很多人有能力帮你，也乐于帮你，对于学习来说，太重要了。 当然缺点也是有的，正如前面说的，要grid改起来比较麻烦，当然其实会grid的人也不多，别一方面是版本上的不兼容，这在前面也提及到，好在现在的版本已经趋于稳定，应该不会有太大的变动。 1.2 base plot vs ggplot2 "],
["chapter-grammar-graphics.html", "Chapter 2 图形语法简介", " Chapter 2 图形语法简介 "],
["chapter-distribution.html", "Chapter 3 可视化数据分布", " Chapter 3 可视化数据分布 "],
["chapter-multi-distribution.html", "Chapter 4 可视化多个数据分布", " Chapter 4 可视化多个数据分布 "],
["chapter-ratio.html", "Chapter 5 可视化比值", " Chapter 5 可视化比值 abcd "],
["chapter-facet.html", "Chapter 6 不一样的分面 6.1 背景数据 6.2 特定的分面 6.3 额外的分面 6.4 坐标轴截断 6.5 不想干的分面", " Chapter 6 不一样的分面 分面（facet）是将数据分解成多个子集，对各个子集分别进行作图，并联合进行展示。比如我们所熟知的数据iris和mtcars中，iris中有三个物种，而mtcars中的车有4、6和8个轮子的。我们可以按照这些分类变量，对数据进行切割作图。比如： library(ggplot2) ggplot(mtcars, aes(mpg, disp)) + geom_point() + facet_grid(. ~ cyl) ggplot2提供了facet_grid()和facet_wrap()两个函数，来实现分面可视化。上面的示例向我们展示了分面的用法，它提供给我们以纵向或横向的形式比较不同的类别，这里比较一个变量cyl（轮子数）中的三个元素，这是分面最常用的用法，同一变量中不同的取值，对数据进行切割，以横向或纵向比较，比如不同物种中某个相同的特征进行比较，按照月份切割可视化一年的数据，机器学习中训练集和测试集的比较。 6.1 背景数据 ggplot(mtcars, aes(mpg, disp)) + geom_point(data = mtcars[, -2], color = &#39;grey&#39;) + geom_point(aes(color = factor(cyl))) + facet_grid(. ~ cyl) 6.2 特定的分面 d &lt;- data.frame(mpg=20, disp=280, cyl=6, label=&quot;额外的数据&quot;) ggplot(mtcars, aes(mpg, disp)) + geom_point(data = mtcars[, -2], color = &#39;grey&#39;) + geom_point(aes(color = factor(cyl))) + facet_grid(. ~ cyl) + geom_point(data = d, shape = 2, size=10, color = &#39;red&#39;) + geom_text(aes(label=label), data = d, size=5) 6.3 额外的分面 d &lt;- data.frame(mpg=sample(mtcars$mpg, 20), disp=sample(mtcars$disp, 20), cyl=2) ggplot(mtcars, aes(mpg, disp)) + geom_point(data = mtcars[, -2], color = &#39;grey&#39;) + geom_point(aes(color = factor(cyl))) + facet_grid(. ~ cyl) + geom_point(data = d) 这样就加上额外的分面了，当然有一个问题是额外加的分面没有上色，这个解决方案就是先不加色，而在后面再映射颜色。 ggplot(mtcars, aes(mpg, disp)) + geom_point(data = mtcars[, -2], color = &#39;grey&#39;) + geom_point() + facet_grid(. ~ cyl) + geom_point(data = d) + aes(color = factor(cyl)) 6.4 坐标轴截断 set.seed(2019-01-19) d &lt;- data.frame( x = 1:20, y = c(rnorm(5) + 4, rnorm(5) + 20, rnorm(5) + 5, rnorm(5) + 22) ) ggplot(d, aes(x, y)) + geom_col() library(dplyr) breaks = c(7, 17) d$.type &lt;- NA d$.type[d$y &lt; breaks[1]] = &quot;small&quot; d$.type[d$y &gt; breaks[2]] = &quot;big&quot; d &lt;- filter(d, .type == &#39;big&#39;) %&gt;% mutate(.type = &quot;small&quot;, y = breaks[1]) %&gt;% bind_rows(d) mymin = function(y) ifelse(y &lt;= breaks[1], 0, breaks[2]) p &lt;- ggplot(d, aes(x, y)) + geom_rect(aes(xmin = x - .4, xmax = x + .4, ymin = mymin(y), ymax = y)) + facet_grid(.type ~ ., scales = &quot;free&quot;) + theme(strip.text=element_blank()) p 6.5 不想干的分面 在额外的分面一节中，应该看出一点端倪。 如ggtree中的facet_plot "],
["chapter-summary.html", "Chapter 7 统计量", " Chapter 7 统计量 library(ggplot2) pups &lt;- nlme::RatPupWeight %&gt;% janitor::clean_names() %&gt;% dplyr::mutate(litter = as.integer(litter)) p &lt;- ggplot(pups, aes(x = litter, y = weight, color = treatment)) 针对某一个x值，我们可以画出相应y的统计量，比如均值、方差等，这些都可以“手工”的方式通过图层叠加来实现。 p + geom_jitter(shape=1) + stat_summary(fun.y = &quot;mean&quot;, size=2, geom=&quot;point&quot;, color = &#39;black&#39;) + stat_summary(fun.data = mean_cl_normal, geom=&quot;errorbar&quot;, width=.1, color=&#39;black&#39;) 而图层不单单是画出几何图形而已，有一些是需要计算统计量的，最常见也最容易理解的箱式图图层geom_boxplot，需要计算四分位数，而有一些图层虽然看上去不需要做计算，比如显示误差的geom_errorbar，通常需要我们提供ymin和ymax，然而它按照我们提供的值去显示，没有涉及到图层内部的计算，但这只是默认行为而已，如果有留意ggplot2图层的默认参数的话，大概是会发现很多图层都有一个stat = \"identity\"的参数，这表示按照输入数据的值来画，不涉及计算，比如画柱状图的geom_col就是这样，它会按照用户输入的计算来画柱子的高度，而geom_bar的参数却不stat = \"count\"它则会去数数。所以这些图层都有stat参数，意味着我们可以改变默认行为的统计量来画图，比如说箱式图吧，箱体是25%, 50%, 70%的分位数来画的，假设我想用mean-sd, mean, mean+sd来画呢？当然可以。 f &lt;- function(y) { r &lt;- quantile(y, probs = c(0.05, 0.25, 0.5, 0.75, 0.95)) r[2] &lt;- mean(y) - sd(y) r[3] &lt;- mean(y) r[4] &lt;- mean(y) + sd(y) names(r) &lt;- c(&quot;ymin&quot;, &quot;lower&quot;, &quot;middle&quot;, &quot;upper&quot;, &quot;ymax&quot;) r } p1 &lt;- p + stat_summary(fun.data=f, geom=&#39;boxplot&#39;, width=.8) p2 &lt;- p + geom_boxplot(aes(group = litter)) cowplot::plot_grid(p1, p2, labels = c(&quot;mean +- sd&quot;, &quot;quantile&quot;)) 这一招也是我在Proteomic investigation of the interactome of FMNL1 in hematopoietic cells unveils a role in calcium-dependent membrane plasticity图一中把箱式图的中位数换成均值所使用的方法。 使用stat_smooth(method = \"lm\", formula = y ~ 1)，可以展示某一x取值区间的平均y值。 p + geom_point() + stat_smooth(method = &quot;lm&quot;, formula = y ~ 1) 如果要计算中位数的话，可以使用rlm： library(MASS) p + geom_point() + stat_smooth(method = &quot;rlm&quot;, formula = y ~ 1) "],
["references.html", "References", " References "]
]
